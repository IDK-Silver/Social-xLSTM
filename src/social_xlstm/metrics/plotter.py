"""
TrainingMetricsPlotter - Basic visualization for training metrics CSV data.

Generates matplotlib plots for MAE, MSE, RMSE, RÂ² metrics from CSV files
created by TrainingMetricsWriter.
"""

import csv
import warnings
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np


class TrainingMetricsPlotter:
    """
    Basic plotter for training metrics CSV data.
    
    Reads CSV files generated by TrainingMetricsWriter and creates simple
    matplotlib plots for visualization without complex dashboards.
    """
    
    def __init__(
        self,
        csv_path: Union[str, Path],
        metrics: Tuple[str, ...] = ("mae", "mse", "rmse", "r2"),
        splits: Tuple[str, ...] = ("train", "val"),
    ):
        """
        Initialize TrainingMetricsPlotter.
        
        Args:
            csv_path: Path to metrics CSV file
            metrics: Tuple of metric names to plot
            splits: Tuple of data splits to visualize
        """
        self.csv_path = Path(csv_path)
        self.metrics = metrics
        self.splits = splits
        
        # Data storage
        self._data: Dict[str, Dict[str, List[float]]] = {}
        self._epochs: Dict[str, List[int]] = {}
        
        # Load data on initialization
        self._load_data()
    
    def _load_data(self) -> None:
        """Load metrics data from CSV file."""
        if not self.csv_path.exists():
            raise FileNotFoundError(f"CSV file not found: {self.csv_path}")
        
        # Initialize data structures
        for split in self.splits:
            self._data[split] = {metric: [] for metric in self.metrics}
            self._epochs[split] = []
        
        try:
            with open(self.csv_path, 'r') as f:
                reader = csv.DictReader(f)
                
                for row in reader:
                    split = row['split']
                    epoch = int(row['epoch'])
                    
                    # Skip if split not in our tracking list
                    if split not in self.splits:
                        continue
                    
                    # Record epoch
                    self._epochs[split].append(epoch)
                    
                    # Record metrics
                    for metric in self.metrics:
                        if metric in row and row[metric] != 'nan':
                            value = float(row[metric])
                            self._data[split][metric].append(value)
                        else:
                            # Fill missing values with NaN
                            self._data[split][metric].append(float('nan'))
                            
        except Exception as e:
            raise RuntimeError(f"Failed to load CSV data: {e}") from e
        
        # Validate data consistency
        self._validate_data()
    
    def _validate_data(self) -> None:
        """Validate that data is consistent across splits and metrics."""
        for split in self.splits:
            if not self._epochs[split]:
                warnings.warn(f"No data found for split '{split}'")
                continue
            
            epoch_count = len(self._epochs[split])
            for metric in self.metrics:
                metric_count = len(self._data[split][metric])
                if metric_count != epoch_count:
                    warnings.warn(
                        f"Data inconsistency for {split}:{metric} "
                        f"({metric_count} values vs {epoch_count} epochs)"
                    )
    
    def plot_single_metric(
        self, 
        metric: str, 
        figsize: Tuple[float, float] = (10, 6),
        save_path: Optional[Union[str, Path]] = None
    ) -> plt.Figure:
        """
        Plot single metric across all splits.
        
        Args:
            metric: Metric name to plot
            figsize: Figure size (width, height)
            save_path: Optional path to save plot
            
        Returns:
            matplotlib Figure object
        """
        if metric not in self.metrics:
            raise ValueError(f"Metric '{metric}' not available. Available: {self.metrics}")
        
        fig, ax = plt.subplots(figsize=figsize)
        
        # Plot each split
        for split in self.splits:
            if not self._epochs[split]:
                continue
            
            epochs = np.array(self._epochs[split], dtype=int)
            values = np.array(self._data[split][metric])
            
            # Filter out NaN values for plotting
            valid_mask = ~np.isnan(values)
            if not np.any(valid_mask):
                warnings.warn(f"No valid data for {split}:{metric}")
                continue
            
            ax.plot(
                epochs[valid_mask] + 1, 
                values[valid_mask], 
                label=f"{split.title()}",
                marker='o',
                markersize=4,
                linewidth=2
            )

        # Force x-axis to start at 1 and end at last epoch shown
        try:
            max_epoch_disp = 1
            for split in self.splits:
                if not self._epochs[split]:
                    continue
                epochs = np.array(self._epochs[split], dtype=int)
                values = np.array(self._data[split][metric])
                valid_mask = ~np.isnan(values)
                if np.any(valid_mask):
                    max_epoch_disp = max(max_epoch_disp, int(epochs[valid_mask].max()) + 1)
            ax.set_xlim(left=1, right=max_epoch_disp)
            # Set integer ticks that always include 1
            span = max_epoch_disp - 1
            max_ticks = 10
            step = int(np.ceil(span / max_ticks)) if span > 0 else 1
            step = max(step, 1)
            ticks = list(range(1, max_epoch_disp + 1, step))
            if ticks[-1] != max_epoch_disp:
                ticks.append(max_epoch_disp)
            ax.set_xticks(ticks)
        except Exception:
            ax.set_xlim(left=1)

        # Styling
        disp = "MAP" if metric.lower() == "mape" else metric.upper()
        ax.set_xlabel("Epoch")
        ax.set_ylabel(disp)
        ax.set_title(f"Training Progress: {disp}")
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            fig.savefig(save_path, dpi=150, bbox_inches='tight')
            
        return fig
    
    def plot_all_metrics(
        self, 
        figsize: Tuple[float, float] = (15, 10),
        save_path: Optional[Union[str, Path]] = None
    ) -> plt.Figure:
        """
        Plot all metrics in a 2x2 subplot layout.
        
        Args:
            figsize: Figure size (width, height)
            save_path: Optional path to save plot
            
        Returns:
            matplotlib Figure object
        """
        n_metrics = len(self.metrics)
        
        # Create subplot layout
        if n_metrics <= 2:
            nrows, ncols = 1, n_metrics
        elif n_metrics <= 4:
            nrows, ncols = 2, 2
        else:
            nrows = int(np.ceil(n_metrics / 3))
            ncols = 3
        
        fig, axes = plt.subplots(nrows, ncols, figsize=figsize)
        
        # Handle single subplot case
        if n_metrics == 1:
            axes = [axes]
        elif nrows == 1 or ncols == 1:
            axes = axes.flatten() if hasattr(axes, 'flatten') else [axes]
        else:
            axes = axes.flatten()
        
        # Plot each metric
        for i, metric in enumerate(self.metrics):
            ax = axes[i]

            # Plot each split for this metric
            for split in self.splits:
                if not self._epochs[split]:
                    continue
                
                epochs = np.array(self._epochs[split], dtype=int)
                values = np.array(self._data[split][metric])
                
                # Filter out NaN values
                valid_mask = ~np.isnan(values)
                if not np.any(valid_mask):
                    continue
                
                ax.plot(
                    epochs[valid_mask] + 1,
                    values[valid_mask],
                    label=f"{split.title()}",
                    marker='o',
                    markersize=3,
                    linewidth=1.5
                )

            # Annotate best points per split (min for most, max for r2)
            for split in self.splits:
                if not self._epochs[split]:
                    continue
                epochs = np.array(self._epochs[split], dtype=int)
                values = np.array(self._data[split][metric], dtype=float)
                valid_mask = ~np.isnan(values)
                if not np.any(valid_mask):
                    continue
                if metric.lower() == 'r2':
                    best_idx = np.nanargmax(values)
                else:
                    best_idx = np.nanargmin(values)
                ex = epochs[best_idx]
                ey = values[best_idx]
                ex_disp = int(ex) + 1
                ax.scatter([ex_disp], [ey], s=30, zorder=5)
                ax.annotate(
                    f"{split}:{ey:.4f}\n(ep {ex_disp})",
                    (ex_disp, ey),
                    textcoords="offset points",
                    xytext=(6, 6),
                    ha='left',
                    fontsize=8,
                    bbox=dict(boxstyle='round,pad=0.2', fc='white', ec='gray', alpha=0.6)
                )

            # Styling for this subplot
            disp = "MAP" if metric.lower() == "mape" else metric.upper()
            ax.set_xlabel("Epoch")
            ax.set_ylabel(disp)
            ax.set_title(f"{disp}")
            ax.legend()
            ax.grid(True, alpha=0.3)

            # Force x-axis to start at 1 and end at last epoch shown
            try:
                max_epoch_disp = 1
                for split in self.splits:
                    if not self._epochs[split]:
                        continue
                    epochs = np.array(self._epochs[split], dtype=int)
                    values = np.array(self._data[split][metric])
                    valid_mask = ~np.isnan(values)
                    if np.any(valid_mask):
                        max_epoch_disp = max(max_epoch_disp, int(epochs[valid_mask].max()) + 1)
                ax.set_xlim(left=1, right=max_epoch_disp)
                # Set integer ticks that always include 1
                span = max_epoch_disp - 1
                max_ticks = 8
                step = int(np.ceil(span / max_ticks)) if span > 0 else 1
                step = max(step, 1)
                ticks = list(range(1, max_epoch_disp + 1, step))
                if ticks[-1] != max_epoch_disp:
                    ticks.append(max_epoch_disp)
                ax.set_xticks(ticks)
            except Exception:
                ax.set_xlim(left=1)
        
        # Hide unused subplots
        for i in range(n_metrics, len(axes)):
            axes[i].set_visible(False)
        
        plt.suptitle("Training Metrics Overview", fontsize=16, y=0.98)
        plt.tight_layout()
        
        if save_path:
            fig.savefig(save_path, dpi=150, bbox_inches='tight')
            
        return fig
    
    def get_final_metrics(self) -> Dict[str, Dict[str, float]]:
        """
        Get final epoch metrics for each split.
        
        Returns:
            Dictionary with final metrics by split
        """
        final_metrics = {}
        
        for split in self.splits:
            if not self._epochs[split]:
                continue
            
            # Get index of final epoch
            final_idx = len(self._epochs[split]) - 1
            
            final_metrics[split] = {}
            for metric in self.metrics:
                if final_idx < len(self._data[split][metric]):
                    value = self._data[split][metric][final_idx]
                    final_metrics[split][metric] = value if not np.isnan(value) else None
                else:
                    final_metrics[split][metric] = None
        
        return final_metrics
    
    def print_summary(self) -> None:
        """Print a summary of the loaded metrics data."""
        print(f"Metrics CSV: {self.csv_path}")
        print(f"Metrics tracked: {', '.join(self.metrics)}")
        print(f"Splits tracked: {', '.join(self.splits)}")
        print()
        
        for split in self.splits:
            if not self._epochs[split]:
                print(f"{split.upper()}: No data")
                continue
            
            n_epochs = len(self._epochs[split])
            epoch_range = f"{min(self._epochs[split])}-{max(self._epochs[split])}"
            
            print(f"{split.upper()}: {n_epochs} epochs (range: {epoch_range})")
            
            # Show final metrics
            final_metrics = self.get_final_metrics()
            if split in final_metrics:
                for metric, value in final_metrics[split].items():
                    if value is not None:
                        print(f"  Final {metric}: {value:.4f}")
                    else:
                        print(f"  Final {metric}: N/A")
            print()
    
    @classmethod
    def from_experiment_dir(
        cls,
        experiment_dir: Union[str, Path],
        csv_filename: str = "metrics.csv",
        **kwargs
    ) -> "TrainingMetricsPlotter":
        """
        Create plotter from experiment directory.
        
        Args:
            experiment_dir: Directory containing metrics.csv
            csv_filename: Name of CSV file to load
            **kwargs: Additional arguments for TrainingMetricsPlotter
            
        Returns:
            TrainingMetricsPlotter instance
        """
        csv_path = Path(experiment_dir) / csv_filename
        return cls(csv_path, **kwargs)
